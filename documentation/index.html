<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- $Id Exp $ -->
<!--Generated by quanta Plus template - freely use and distribute-->
<html>
<head>
  <title>SolidGround</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR" content="Quanta Plus">
  <link>
  <style type="text/css">
  </style>
  <script>
  </script>
</head>
<body>

<div align="center"><h1>SolidGroud Framework</h1></div>


<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	<strong>Overview</strong>
	</th>
    </tr>
  </thead>
</table>
SolidGround is a C++ framework intending to offer everything one need to build powerful distributed highly-scalable client-server applications.<br><br>

Here is a list with what the framework is offering:<br><br>

Version 1.0:<br><br>

<ol>
	<LI>A system library which wraps up threads, synchronization objects, thread specific, file access, socket address, debug logging engine etc. </LI>
	<li>Asynchronous signaling engine.</li>
	<li>Asynchronous TCP and UDP communication engine, single-channel and multi-channel(for easily implementing proxies and other communication nodes, e.g. chat rooms).</li>
	<li>Secure Socket support for the asynchronous TCP communication, using OpenSSL library (http://www.openssl.org/).</li>
	<li>Asynchronous multiplexed IPC (Inter Process Communication) / RPC (Remote Procedure Call) engine with keep-alive support for peer disconnection detection. The protocol allows for sending commands (of any size - one can even send file streams) to a peer process over multiplexed UDP.</li>
	<li>A nice serialization engine (for now only binary, non portable - used by IPC)</li>
	<li>A nice asynchronous ready, text protocol engine (parser and response builder) for protocols like IMAP, POP, SMTP etc.</li>
	<li>A file stream manager for asynchronous usage (e.g. if you want a read-only stream for a file which is locked for writing, the manager will signal you the stream when unlocked)</li>
	<li>A nice audit/log engine.</li>
	<li>Doxygen documentation.</li>
	<li>Lots of test applications, including a central proof of concept multi service server.</li>
</ol>

<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	<strong>Links</strong>
	</th>
    </tr>
  </thead>
</table>
<br>
<strong>Home Page:</strong> <A href="http://code.google.com/p/solidground/" name=homepage>http://code.google.com/p/solidground/</A>
<br>
<strong>Wiki:</strong> <A href="http://code.google.com/p/solidground/w/list" name=wiki>http://code.google.com/p/solidground/w/list</A>
<br>
<strong>Download page:</strong> <A href="http://code.google.com/p/solidground/downloads/list" name=documentation>http://code.google.com/p/solidground/downloads/list</A>
<br>

<strong>Fetch latest source:</strong> svn checkout http://solidground.googlecode.com/svn/trunk/ solidground-read-only

<br><br>


<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	<a href="html/index.html"><strong>Documentation:</strong></LI>
	
	</th>
    </tr>
  </thead>
</table>
<p>API Documentation generated by <a href="http://www.doxygen.org/" name="Doxygen">Doxygen</a> can be found
<a href="html/index.html">here</a>.
<br><br>
<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	<strong>Build and test the proof of concept server</strong>
	</th>
    </tr>
  </thead>
</table>

Before anything you must ensure you have all the needed packages installed on your Linux box. You'll need: gcc-c++, boost, boost-devel, cmake (on a fedora box: "yum install gcc-c++ cmake" will suffice). Eventually you'll need "subversion" to fetch a copy of solidground repository (fedora:"yum install subversion").
<br>
The solidground framework, has a commodity build script which can be used to create certain builds for certain base build systems (make or kdevelop3 - run <pre>./configure --help</pre> to se the options).
<br>
<br>
First you'll need the solidground code - see above how you can do that. E.g.:
<pre style="font-family : monospace;">
work $ svn checkout http://solidground.googlecode.com/svn/trunk/ solidground
</pre>
Next you need to build the external libraries, SolidGround uses:
<pre style="font-family : monospace;">
work $ mkdir sg_extern
work $ cd sg_extern
sg_extern $ wget "http://garr.dl.sourceforge.net/sourceforge/boost/boost_1_39_0.tar.bz2"
sg_extern $ wget "http://www.openssl.org/source/openssl-0.9.8k.tar.gz"
sg_extern $ ln -s ../solidground/extern/prepare_lin.sh .
sg_extern $ ./prepare_lin.sh
</pre>

Now, lets build a debug version of the proof of concept server.

<pre style="font-family : monospace;">
solidground $ ./configure -f dbg -b debug -e ~/work/sg_extern
solidground $ cd build/dbg/test/foundation/main

main $ make
</pre>

The above commands will start building the proof of concept clientserver test application. When it's done the application is created within the main directory, and you can start using it:

<pre style="font-family : monospace;">main $ ./test_concept --help</pre>

To see the parameters accepted.

<pre style="font-family : monospace;">main $ ./test_concept -b 1000</pre>

The application should start printing some information and offering a small CLI (Command Line Interface) on which you can type help to see the commands.

The test application expects a starting base port value (-b argument) which will be used for opening listening TCP and UDP sockets (default is 1000). There are few services offered by test among which are echo and the most important, alpha.

In the following lines, to show the capabilities of the framework we'll use the alpha protocol which somehow resembles the IMAP protocol in syntax. The alpha service will listen on (base_port + 114) port. So, next you'll need to start a telnet on localhost 1114 (telnet 0 1114) and you should see the alpha banner.

With alpha protocol you can list folder content:

<pre style="font-family : monospace;">aa list "/home"</pre>

Append a new file to an existing folder:

<pre style="font-family : monospace;">ab store "/tmp/000002.txt" {10}

1234567890</pre>

The above command will create "/tmp/000002.txt" and will write the given 10 chars on it.

Fetch files:

<pre style="font-family : monospace;">ac fetch "/tmp/000002.txt"</pre>

Now lets move forward to two more interesting commands. For that we'll need another instance of test listening on different set of ports:

<pre style="font-family : monospace;">main $ ./test_concept -b 2000</pre>

The folowing commands will test the IPC capabilities, remote executing commands issued from the first server on the second server.

The first command is remotelist. Lets issue it on the telnet session;

<pre style="font-family : monospace;">ad remotelist "/home" localhost 2222</pre>

It will send an ipc command to the second server, execute it to build a list of filesystem sub-items of the given path, send the list back to the client connection which will send the command result to the client.

The second command is much more interesting and complex. It will remotely fetch a command.

<pre style="font-family : monospace;">ae fetch "/tmp/000002.txt" localhost 2222</pre>

Here's what the command does:
<ol>
	<li>Create a temporary file.</li>
	<LI>Send an ipc master command which will open a stream to the requested file on the remote server and send back a response with the first 1MB of the file</LI>
	<li>On the first server the first 1MB of file is writen to the temp file</li>
	<LI>Then the fetch command issues another request (using an ipc slave command) for the next 1MB of data, while starting sending the first 1MB of data to the client.</LI>
	<LI>... and so on</LI>
</ol>

The command is quite complex and quite important as it stresses/tests a lot the IPC service, especially for large files.

<p><strong>Notes:</strong></p>
<ul>
   <li> To close a connection use:
	<pre style="font-family : monospace;">xx logout</pre>
	</li>
   <li> To close the test application type "quit" in the mini CLI</li>
 </ul>
<br><br>
<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	<strong>Build and test the clients for the proof of concept server</strong>
	</th>
    </tr>
  </thead>
</table>

Some alpha commands are too difficult to be thoroughly tested by hand using telnet.
So there are some client applications writen to test some of those commands.

They are located in:

<pre style="font-family : monospace;">solidground/test/client</pre>

Lets build em in release mode.

If you haven't done so yet do:

<pre style="font-family : monospace;">solidground $ ./configure -f rls -b release -e ~/work/sg_extern</pre>

Then do:

<pre style="font-family : monospace;">
solidground $ cd build/rls/test/client<br>
client $ make
</pre>

Now you have built three clients: <strong>alphaclient_p</strong>, <strong>alphaclient_s</strong>, <strong>alphafetch_p</strong>, <strong>alphastore_p</strong>.

<h3>alphafetch_p</h3>

As its name says this client tests the alpha <strong>fetch</strong> command on plain a connection.<br>
Usage:
<pre>./alphafetch_p alpha_addr alpha_port ipc_addr ipc_port path local_path</pre>

Where:
<ul>
<li><strong>alpha_addr</strong>: address of the alpha server</li>
<li><strong>alpha_port</strong>: port of the alpha server</li>
<li><strong>ipc_addr</strong>: the base ipc address of the remote server (used for remote fetching) - use "" for local fetch</li>
<li><strong>ipc_port</strong>: the base ipc port of the remote server (used for remote fetching) - use "" for local fetch</li>
<li><strong>path</strong>: the path to requested file</li>
<li><strong>local_path</strong>: the local file to write to</li>
</ul>


<h3>alphastore_p</h3>

This one tests the alpha store command for storing a file on the server on a plain connection.

Usage:
<pre>./alphastore_p alpha_addr alpha_port local_path path</pre>

Where:
<ul>
<li><strong>alpha_addr</strong>: address of the alpha server</li>
<li><strong>alpha_port</strong>: port of the alpha server</li>
<li><strong>local_path</strong>: the local source file</li>
<li><strong>path</strong>: the path to destination file on the server</li>
</ul>

<h3>alphaclient_p/alphaclient_s</h3>

This is a fetch stress test for alpha server on plain/secure connections.

Usage:
<pre>./alphaclient_s thcnt addr port path tout [remote_addr remote_base_port]</pre>

Where:
<ul>
<LI><strong>thcnt</strong>: thread and client connections count</LI>
<li><strong>addr</strong>: the address of the alpha server</li>
<li><strong>port</strong>: the port of the alpha server</li>
<li><strong>path</strong>: the path to the parent folder - see below</li>
<li><strong>tout</strong>: time out between commands in msec</li>
<li><strong>remote_addr</strong>: for testing remotelist and remote fetch, the address of the peer server</li>
<li><strong>remote_base_port</strong>: for testing remotelist and remote fetch, the base_port of the peer server</li>
</ul>

Basically it oppens thcnt connections to alpha server, and on every connection it
first issues a LIST command to get the list of files located within given parent folder,
then it cyclically issues FETCH commands for every file.

<br><br>

While fetching alphaclient_p displays certain statistical information like:
<br>
<ul>
<LI>total transfer speed in KB/s,</LI>
<LI>the average amount of data transfered on connections in KB,</LI>
<LI>the minimum amount of data in KB transfered on a connection and the count of connection with that minimum,</LI>
<LI>the maximum amount of data in KB transfered on a connection and the count of connection with that maximum.</LI>
</ul>

Example:
<pre>speed = 20526k/s avg = 30790k min = 29788k (1) max = 31241k (1)</pre>

So we have 20MB/s total transfer rate (localhost), a current average transfer of 30 MB and one connection
with a minimum transfer of 29MB and one with a maximum transfer of 31MB.

<br><br>
<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	<strong>License</strong>
	</th>
    </tr>
  </thead>
</table>

Copyright 2007, 2008 Valentin Palade <br>
	&nbsp;&nbsp;&nbsp;vipalade@gmail.com<br>
<br>
SolidGround is free software: you can redistribute it and/or modify<br>
it under the terms of the GNU General Public License as published by<br>
the Free Software Foundation, either version 3 of the License, or<br>
(at your option) any later version.<br>

SolidGround is distributed in the hope that it will be useful,<br>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br>
GNU General Public License for more details.<br>

You should have received a copy of the GNU General Public License<br>
along with SolidGround.  If not, see <A href="http://www.gnu.org/licenses/" name=license>http://www.gnu.org/licenses/</A>.<br>

<br><br>
<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	
	</th>
    </tr>
  </thead>
</table>


</body>
</html>