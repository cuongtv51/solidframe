<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- $Id Exp $ -->
<!--Generated by quanta Plus template - freely use and distribute-->
<html>
<head>
  <title>SolidGround</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR" content="Quanta Plus">
  <link>
  <style type="text/css">
  </style>
  <script>
  </script>
</head>
<body>

<div align="center"><h1>SolidGroud Framework</h1></div>


<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	<strong>Overview</strong>
	</th>
    </tr>
  </thead>
</table>
SolidGround is a C++ framework intending to offer everything one need to build powerful distributed highly-scalable client-server applications.<br><br>

Here is a list with what the framework is offering for now:

<ol>
	<li> a system library which wraps up threads, synchronization objects, thread specific, file access, socket address etc. </li>
	<li> asynchronous signaling engine </li>
	<li> asynchronous TCP and UDP communication engine </li>
	<li> asynchronous multiplexed IPC (inter process communication) engine (for now only over UDP) </li>
	<li> asynchronous file manager for non-conflicting file access (multiple reads are allowed, only a single write at a time and no read while there are pending writes)</li>
	<li> a nice serialization engine (for now only binary, non portable - used by IPC) </li>
	<li> a nice asynchronous ready, text protocol engine (parser and response builder) for protocols like IMAP, POP, SMTP etc.</li>
	<li> lots of test applications, including a central proof of concept multi service server </li>
</ol>

<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	<strong>Links</strong>
	</th>
    </tr>
  </thead>
</table>
<br>
<strong>Home Page:</strong> <A href="http://code.google.com/p/solidground/" name=homepage>http://code.google.com/p/solidground/</A>
<br>
<strong>Wiki:</strong> <A href="http://code.google.com/p/solidground/w/list" name=wiki>http://code.google.com/p/solidground/w/list</A>
<br>
<strong>Download documentation html:</strong> <A href="http://code.google.com/p/solidground/" name=documentation>http://code.google.com/p/solidground/</A>
<br>

<strong>Fetch Source:</strong> svn checkout http://solidground.googlecode.com/svn/trunk/ solidground-read-only

<br><br>


<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	<a href="html/index.html"><strong>Documentation:</strong></a>
	
	</th>
    </tr>
  </thead>
</table>
<p>API Documentation generated by <a href="http://www.doxygen.org/" name="Doxygen">Doxygen</a> can be found
<a href="html/index.html">here</a>.
<br><br>
<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	<strong>Build and test the proof of concept server</strong>
	</th>
    </tr>
  </thead>
</table>

Before anything you must ensure you have all the needed packages installed on you Linux box. You'll need: gcc-c++, boost, boost-devel, cmake, ccache (on a fedora box: "yum install gcc-c++ boost boost-devel cmake ccache" will suffice). Eventually you'll need "subversion" to fetch a copy of solidground repository (fedora:"yum install subversion").
<br>
The solidground framework, has a commodity build script which can be used to create certain builds for certain base build systems (make or kdevelop3 - run <pre>./build.sh</pre> with no parameters to se the options).
<br>
So lets build a (debug-)nolog version.

<pre style="font-family : monospace;">solidground $ ./build.sh nolog

solidground $ cd build/nolog/test/clientserver/main

main $ make
</pre>

The above commands will star building the proof of concept clientserver test application. When it's done the application is create within the main directory, and you can start using it:

<pre style="font-family : monospace;">main $ ./test</pre>

The application should start printing some information and offering a small CLI on which you can type help to see the commands.

The test application expects a starting port value which will be used for opening listening tcp and udp sockets (default is 1000). There are few services offered by test among which are echo and the most important, alpha.

In the following lines, to show the capabilities of the framework we'll use the alpha protocol which somehow resembles the IMAP protocol in syntax. The alpha service will listen on (x + 114) port, where x is the value given as parameter to test application. So, next you'll need to start a telnet on localhost 1114 (telnet 0 1114) and you should see the alpha banner.

With alpha you can list folder content:

<pre style="font-family : monospace;">aa list "/home"</pre>

Append a new file to an existing folder:

<pre style="font-family : monospace;">ac store "/tmp/000002.txt" {10}

1234567890</pre>

The above command will create "/tmp/000002.txt" and will write the given 10 chars on it.

Fetch files:

<pre style="font-family : monospace;">ab fetch "/tmp/000002.txt"</pre>

Now lets move forward to two more interesting commands. For that we'll need another instance of test listening on different set of ports:

<pre style="font-family : monospace;">main $ ./test 2000</pre>

We'll also need a new telnet alpha session on the new test instance:

<pre>telnet 0 2114</pre>

On this telnet session first copy from the banner what is between brackets (something like "2222 83886081 0") and then we'll issue the idle command:

<pre style="font-family : monospace;">ba idle</pre>

To exit from the idle command type done, but for now lets leave the session this way - in idle.

Now go back to the first alpha session opened on the first test instance, and issue:

<pre style="font-family : monospace;">ad sendstring localhost 2222 83886081 0 "one nice string"</pre>

(please replace "2222 83886081 0" with what you've copied from the banner of the second alpha connection)

Now go to the second alpha connection to see the marvel.

Now lets send something nicer, a file from the first alpha session:

<pre style="font-family : monospace;">ae sendstream localhost 2222 83886081 0 "/tmp/000002.txt" "/tmp/rcvd-000002.txt"</pre>

<p>And, you guessed!, back to the second alpha connection to see a new marvel.</p>

Notable is that the last two commands can be used with the test instances on different machines, in which case 'localhost' can be replaced with the name/address of the peer (this way the test can be started without parameter in which case in the above alpha commands you'll need to replace 2222 with 1222). Also don't forget to add new firewall rules for used ports (on my machine I'm allowing for 1114(tcp) and 1222(udp)).

<p>In the end lets go back to the idle connection and type:</p>

<pre style="font-family : monospace;">done</pre>

... to end the idle command.<br>
Then lets remotely fetch the file stored above ("/tmp/000002.txt"):

<pre style="font-family : monospace;">bb fetch "/tmp/000002.txt" localhost 1222</pre>

<p><strong>Notes:</strong></p>
<ul>
   <li> To close a connection use:
	<pre style="font-family : monospace;">xx logout</pre>
	</li>
   <li> To close the test application type "quit" in the mini CLI</li>
 </ul>
<br><br>
<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	<strong>Build and test the clients for the proof of concept server</strong>
	</th>
    </tr>
  </thead>
</table>

Some alpha commands are too difficult to be thoroughly tested by hand using telnet.
So there are some client applications writen to test some of those commands.

They are located in:

<pre>solidground/test/client</pre>

Lets build em in release mode.

If you haven't done so yet do:

<pre>solidground$ ./build.sh release</pre>

Then do:

<pre>
solidground $ cd build/release/test/client<br>
client $ make
</pre>

Now you have built three clients: <strong>alphaclienta</strong>, <strong>alphafetch</strong>, <strong>alphastore</strong>.

<h3>alphafetch</h3>

As its name says this client tests the alpha <strong>fetch</strong> command.<br>
Usage:
<pre>./alphafetch alpha_addr alpha_port ipc_addr ipc_port path local_path</pre>

Where:
<ul>
<li><strong>alpha_addr</strong>: address of the alpha server</li>
<li><strong>alpha_port</strong>: port of the alpha server</li>
<li><strong>ipc_addr</strong>: used for remote fetching the base address of the remote server - use "" for local fetch</li>
<li><strong>ipc_port</strong>: used for remote fetching the base port of the remote server - use "" for local fetch</li>
<li><strong>path</strong>: the path to requested file</li>
<li><strong>local_path</strong>: the local file to write to</li>
</ul>


<h3>alphastore</h3>

This one tests the alpha store command for storing a file on the server.

Usage:
<pre>./alphastore alpha_addr alpha_port local_path path</pre>

Where:
<ul>
<li><strong>alpha_addr</strong>: address of the alpha server</li>
<li><strong>alpha_port</strong>: port of the alpha server</li>
<li><strong>local_path</strong>: the local source file</li>
<li><strong>path</strong>: the path to destination file on the server</li>
</ul>

<h3>alphaclienta</h3>

This is a fetch stress test for alpha server. 

Usage:
<pre>./alphaclient thcnt addr port path tout</pre>

Where:
<ul>
<LI><strong>thcnt</strong>: thread and client connections count</LI>
<li><strong>addr</strong>: the address of the alpha server</li>
<li><strong>port</strong>: the port of the alpha server</li>
<li><strong>path</strong>: the path to the parent folder - see below</li>
<li><strong>tout</strong>: time out between commands in msec</li>
</ul>

Basically it oppens thcnt connections to alpha server, and on every connection it
first issues a LIST command to get the list of files located within given parent folder,
then it cyclically issues FETCH commands for every file.

<br><br>

While fetching alphaclienta displays certain statistical information like:
<br>
<ul>
<LI>total transfer speed in KB/s,</LI>
<LI>the average amount of data transfered on connections in KB,</LI>
<LI>the minimum amount of data in KB transfered on a connection and the count of connection with that minimum,</LI>
<LI>the maximum amount of data in KB transfered on a connection and the count of connection with that maximum.</LI>
</ul>

Example:
<pre>speed = 20526k/s avg = 30790k min = 29788k (1) max = 31241k (1)</pre>

So we have 20MB/s total transfer rate (localhost), a current average transfer of 30 MB and one connection
with a minimum transfer of 29MB and one with a maximum transfer of 31MB.

<br><br>
<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	<strong>License</strong>
	</th>
    </tr>
  </thead>
</table>

Copyright 2007, 2008 Valentin Palade <br>
	&nbsp;&nbsp;&nbsp;vipalade@gmail.com<br>
<br>
SolidGround is free software: you can redistribute it and/or modify<br>
it under the terms of the GNU General Public License as published by<br>
the Free Software Foundation, either version 3 of the License, or<br>
(at your option) any later version.<br>

SolidGround is distributed in the hope that it will be useful,<br>
but WITHOUT ANY WARRANTY; without even the implied warranty of<br>
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br>
GNU General Public License for more details.<br>

You should have received a copy of the GNU General Public License<br>
along with SolidGround.  If not, see <A href="http://www.gnu.org/licenses/" name=license>http://www.gnu.org/licenses/</A>.<br>

<br><br>
<table width="100%" border="0" align="left">
  <thead align="left" valign="left" bgcolor="black">
    <tr>
      <th style="color : #ea851f;">
	
	</th>
    </tr>
  </thead>
</table>


</body>
</html>