//

struct frame::ActionContext{
	error_code	error;
};

struct frame::Action{
	bool		done;
	CbkPtrT		pcbk;
};

class frame::CompletionHandler{
private:
	void handleCompletion(ActionContext &_rctx){
		cassert(pacc);
		(*pact->pcbk)(this, _rctx);
	}
protected:
	ObjectBase				&robj;
	CompletionHandler		*pobjprev;
	CompletionHandler		*pobjnext;//double linked list within the object
	size_t					selidx;//index within selector
	Action					*pact;
};

//for selector
struct ObjectStub{
	ObjectPointerT		objptr;
	uint32				uid;
	CompletionHandler	*pch;
};


class frame::ObjectBase{
public:
	
private:
	void onRegisterToSelector(Selector &_rsel){
		FOR_EACH(it, complvec.begin(), complvec.end()){
			it->registerToSelector(_rsel);
		}
	}
	void onUnregisterFromSelector(Selector &_rsel){
		FOR_EACH(it, complvec.begin(), complvec.end()){
			it->unregisterFromSelector(_rsel);
		}
	}
	void registerCompletionHandler(CompletionHandler &_rcplhnd){
		
	}
	void unregisterCompletionHandler(CompletionHandler &_rcplhnd){
	}
private:
	struct NotificationStub{
		size_t					event;
		DynamicPointer<Message> msgptr;
		size_t					index;
	};
	typedef std::vector<NotificationStub>		NotificationVectorT;
	
	CompletionHandler			*pcmplst;
	NotificationVectorT			ntfvec;
	IndexT						fullid;

	ATOMIC_NS::atomic<IndexT>	thrid;
};

class frame::Object: public frame::ObjectBase{
public:
	struct ExecuteContext{
		size_t event()const{
			return ev;
		}
		size_t index()const{
			return idx;
		}
		DynamicPointer<Message>& message(){
			return msgptr;
		}
		
		const TimeSpec& time()const{
			return rcrttm;
		}
		
		void reschedule(size_t _event, size_t _index = 0);
		void close();
		
	protected:
		
	};
private:
	virtual void execute(ExecuteContext &_rctx) = 0;
};

/*
 * This way we can still have two separate selectors one 
 * for frame::Objects and one for frame::aio::Objects
 * and a frame::aio::Object cannot be pushed into
 * a frame::Scheduler - but only into a frame::aio::Scheduler
 */
class frame::aio::Object: public frame::ObjectBase{
public:
	struct ExecuteContext{
		size_t event()const{
			return ev;
		}
		size_t index()const{
			return idx;
		}
		DynamicPointer<Message>& message(){
			return msgptr;
		}
		
		const TimeSpec& time()const{
			return rcrttm;
		}
		
		void reschedule(size_t _event, size_t _index = 0);
		void close();
		
	protected:
		
	};
private:
	virtual void execute(ExecuteContext &_rctx) = 0;
};



class frame::Timer: public CompletionHandler{
public:
	bool waitFor(TimeSpec &_rts, error_code &_rerr, size_t _event = EventTimer, size_t _index = 0){
		
	}
	bool waitUntil(TimeSpec &_rts, error_code &_rerr, size_t _event = EventTimer, size_t _index = 0){
		if(selector()->time() >= _rts){
			return true;
		}
		
		selector()->
	}
	void cancel(){
	}
};

struct frame::aio::ActionContext: frame::ActionContext{
	const bool	hasread;
	const bool	haswrite;
	bool		wantread;
	bool		wantwrite;
};

class frame::aio::ServerSocket: public frame::CompletionHandler{
public:
	bool hasPendingAccept()const{
		
	}
	bool accept(SocketDevice &_raccdev, error_code &_rerr, size_t _event = EventAccept, size_t _index = 0){
		
	}
	bool doneAccept(SocketDevice &_raccdev, error_code &_rerr){
		
	}
private:
	static void completionCallback(frame::CompletionHandler *_pthis, frame::ActionContext &_rctx){
		ServerSocket 		&rthis = *static_cast<ServerSocket*>(_pthis);
		aio::ActionContext	&rctx = static_cast<aio::ActionContext&>(_rctx);
		AcceptAction		*paccact = static_cast<AcceptAction*>(rthis.pact);
		paccact->done = true;
		if(!rctx.error){
			cassert(rctx.hasread);
			if(device.accept(paccact->device)){
			}else{
				paccact->error = last_system_error();
			}
		}else{
			paccact->error = rctx.error;
		}
		aio::Selector::the().schedule(_pthis, paccact->event, paccact->index);
	}
private:
	SocketDevice	device;
};


bool StreamAction::wantWrite()const{
	return this->psndact && !this->psndact->done;
}

class frame::aio::StreamSocket: public frame::CompletionHandler{
public:
	
	bool hasPendingRecv()const{
		
	}
	
	bool recvSome(char *_buf, size_t _bufcp, size_t &_rsz, error_code &_rerr, size_t _event = EventRecv, size_t _index = 0){
		StreamAction		*pstract = static_cast<StreamAction*>(this->pact);
		if(!pstract->prcvact){
			int rv = dev.recv(_buf, _bufcp);
			if(rv > 0){
				_rsz = rv;
				return true;
			}else if(rv == 0){
				_err = SocketClosedError;
				return true;
			}else if(errno == EAGAIN){
				StreamRecvAction *prcvact = aio::Selector::the().popStreamRecvAction();
				prcvact->done = false;
				prcvact->buf = _buf;
				prcvact->bufcp = _bufcp;
				prcvact->event = _event;
				prcvact->index = _index;
				
				pstract->prcvact = prcvact;
				aio::Selector::the().waitIO(this, true/*wantread*/, pstract->wantWrite());
			}else{
				_err = errno;
				return true;
			}
		}else{
			_rerr = OpperationInProgressError;
			return true;
		}
	}
	
	bool doneRecv(size_t &_rsz, error_code &_rerr){
		
	}
	
	bool sendAll(const char *_buf, size_t _bufsz, error_code &_rerr, size_t _event = EventAccept, size_t _index = 0){
		if(!hasPendingSend()){
			int rv = dev.send(_buf, _bufsz);
			if(rv > 0){
				_rsz = rv;
				return true;
			}else if(rv == 0){
				_err = SocketClosedError;
				return true;
			}else if(errno == EAGAIN){
				
			}else{
				_err = errno;
				return true;
			}
		}else{
			_rerr = OpperationInProgressError;
			return true;
		}
	}
private:
	static void completionCallback(frame::CompletionHandler *_pthis, frame::ActionContext &_rctx){
		ServerSocket 		&rthis = *static_cast<ServerSocket*>(_pthis);
		aio::ActionContext	&rctx = static_cast<aio::ActionContext&>(_rctx);
		StreamAction		*pstract = static_cast<StreamAction*>(_pthis->pact);
		
		if(!rctx.error){
			if(rctx.hasread){
				cassert(pstract->prcvact);
				(*pstract->prcvact->pcbk)(_pthis, _rctx);
			}
			if(rctx.haswrite){
				cassert(pstract->psndact);
				(*pstract->psndact->pcbk)(_pthis, _rctx);
			}
		}else{
			if(pstract->prcvact){
				(*pstract->prcvact->pcbk)(_pthis, _rctx);
			}
			if(pstract->psndact){
				(*pstract->psndact->pcbk)(_pthis, _rctx);
			}
		}
	}
	static void completionCallbackRecvSome(frame::CompletionHandler *_pthis, frame::ActionContext &_rctx){
		ServerSocket 		&rthis = *static_cast<ServerSocket*>(_pthis);
		aio::ActionContext	&rctx = static_cast<aio::ActionContext&>(_rctx);
		StreamAction		*pstract = static_cast<StreamAction*>(_pthis->pact);
		StreamRecvAction	*prcvact = static_cast<StreamRecvAction*>(pstract->prcvact);
		
		prcvact->done = true;
		if(!rctx.error){
			int rv = dev.recv(prcvact->buf, prcvact->bufcp);
			if(rv > 0){
				prcvact->rcvsz = rv;
			}else if(rv == 0){
				prcvact->error = SocketClosedError;
			}else{
				prcvact->error = last_system_error();
			}
		}else{
			prcvact->error = rctx.error;
		}
		aio::Selector::the().schedule(_pthis, prcvact->event, prcvact->index);
	}
	
	static void completionCallbackSendAll(frame::CompletionHandler *_pthis, frame::ActionContext &_rctx){
		ServerSocket 		&rthis = *static_cast<ServerSocket*>(_pthis);
		aio::ActionContext	&rctx = static_cast<aio::ActionContext&>(_rctx);
		StreamAction		*pstract = static_cast<StreamAction*>(_pthis->pact);
		StreamSendAction	*psndact = static_cast<StreamRecvAction*>(pstract->psndact);
		
		psndact->done = true;
		
		
	}
private:
	SocketDevice	device;
	
};

class frame::aio::DatagramSocket: public frame::CompletionHandler{
	
};

class frame::aio::openssl::StreamSocket: public frame::CompletionHandler{
private:
	static void completionCallback(frame::CompletionHandler *_pthis, frame::ActionContext &_rctx){
		ServerSocket 		&rthis = *static_cast<ServerSocket*>(_pthis);
		aio::ActionContext	&rctx = static_cast<aio::ActionContext&>(_rctx);
		StreamAction		*pstract = static_cast<StreamAction*>(_pthis->pact);
		
		if(pstract->wantRead()){
			(*pstract->prcvact->pcbk)(_pthis, _rctx);
		}
		if(pstract->wantWrite()){
			(*pstract->psndact->pcbk)(_pthis, _rctx);
		}
	}
};

void aio::Selector::run(){
	bool should_continue = true;
	do{
		const size_t	selcnt = d.selcnt;
		for(size_t i = 0; i < selcnt; ++i){
			CompletionHandlerStub	&rch = d.chstubvec[d.events[i].u64];
			aio::ActionContext		ctx(d.events[i].events);
			
			if(rch.handler->handleCompletion(ctx)){
				d.objevsq.push(ObjectEventStub(ctx));
			}else{
				
			}
		}
		
		while(timerq.size() && timerq.front().time >= crttime){
			const size_t	chidx = timerq.front().idx;
			const uint32	chuid = timerq.front().uid;
			
			timerq.pop();
			cassert(chidx < d.chstubvec.size());
			
			if(d.chstubvec[chidx].uid == chuid){
				CompletionHandlerStub	&rch = d.chstubvec[d.events[i].u64];
				frame::ActionContext	ctx;
			
				rch.handler->handleCompletion(ctx);
				
				d.objevsq.push(ObjectEventStub(ctx));
			}
		}
		
		
		const size_t cnt = d.objevsq.size();
		for(size_t i(0); i < cnt; ++cnt, d.objevsq.pop()){
			ObjectEventStub		&robjevs = d.objevsq.front();
			if(robjevs.objidx < d.objvec.size() && robjevs.objuid == d.objvec[robjevs.objidx].uid){
				ObjectStub 		&ros = d.objvec[robjevs.objidx];
				ExecuteContext	ctx;
				ctx.evt = robjevs.event;
				ctx.msg = robjevs.msgptr;
				ctx.idx = robjevs.index;
				
				ros.objptr->execute(ctx);
			}
		}
	}while(should_continue);
}

void aio::Selector::run(){
	bool should_continue = true;
	do{
		
		
	}while(should_continue);
}



